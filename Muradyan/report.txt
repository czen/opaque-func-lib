# Оглавление
1. [[Введение|Илья Мурадьян. Отчёт по летней практике (2016)#Введение]]
2. [[Постановка задачи|Илья Мурадьян. Отчёт по летней практике (2016)#Постановка задачи]]
3. [[Описание алгоритма|Илья Мурадьян. Отчёт по летней практике (2016)#Описание алгоритма]]
4. [[Результаты численных экспериментов|Илья Мурадьян. Отчёт по летней практике (2016)#Результаты численных экспериментов]]
5. [[Список литературы|Илья Мурадьян. Отчёт по летней практике (2016)#Список литературы]]
6. [[Приложения|Илья Мурадьян. Отчёт по летней практике (2016)#Приложения]]

# Введение

В рамках летней практики на кафедре алгебры и дискретной математики наша группа занималась разработкой библиотеки математических функций с использованием аппроксимаций (ряды Тейлора, аппроксимации Паде, цепные дроби) и без них. Мне было поручено написание тестирующей системы для этой библиотеки. Как оказалось, эта задача не так уж проста - за эти две недели мне пришлось в некоторой мере освоить язык программирования C# и библиотеку Roslyn, которая позволила мне получать синтаксические деревья методов, изменять их и тестировать на лету. Таким образом, практика безусловно пошла мне на пользу и, возможно, несколько повысила мой навык программирования.
Помимо прочего, я освоился с CVS Git и узнал, когда достигается минимальная погрешность при суммировании на ЭВМ. Класс Heap, реализацию которого на псевдокоде можно найти в [1], призван выполнять такое суммирование за O(NlogN).

# Постановка задачи

В самом общем виде задачу можно сформулировать так: научиться тестировать математические функции из библиотеки OpaqueFunctions. Всё остальное по больше части зависело от меня и от отведённого на разработку времени. В итоге я реализовал следующие возможности:

_1. Описал структуру данных Heap (пирамида), которая нужна для аккумуляции значений и выполнения их более или менее эффективного суммирования. Эта структура передаётся по ссылке в изменённую функцию из библиотеки OpaqueFunctions, в которой в специальном месте присутствует комментарий типа

        /// add k

где k - текущий член, добавляемый к сумме. Этот комментарий изменяется моей программой на 

        tst.AddElem(k);

что добавляет текущий элемент в пирамиду. После этого изменённая пирамида выполняет суммирование в нужном порядке за O(NlogN).

_2. Описал классы и методы, которые создают синтаксическое дерево файла, находят в нём атрибуты FunctionName и вытаскивают из этих атрибутов выражения, которые в идеале должны быть корректными с точки зрения C# математическими выражениями (впрочем, я несколько ослабил это требование: выражения эти нечувствительно к регистру). Они компилируется и используется как образцовые функции для сопоставления с написанной студентами аппроксимацией. По каким-то причинам никто не захотел следовать этим вроде бы простым требованиям, и я был вынужден сам написать функции для тестирования своего алгоритма.

# Описание алгоритма
##Пирамида(Heap)

Пирамида, или куча (heap) - это структура данных, позволяющая извлекать минимальный элемент и вставлять элемент за время O(logN), где N - текуще число эементов в структуре. Логически она представляет из себя бинарное дерево, на котором введён порядок кучи, то есть родитель всегда меньше каждого из своих детей, а уровни дерева заполняются всегда сверху вниз, слева направо: у любой кучи только нижний слой может быть незаполненным, причём присутствуют только первые несколько элементов этого слоя. Из-за такой структуры пирамида легко упаковывается в массив - нумерация идёт с 1 слева направо и сверху вниз. Тогда к детям элемента i можно обращаться как 2*i и (2*i+1), а к родителю - [i/2], причём эти операции легко реализуются быстрыми битовыми сдвигами.
Для сохранения порядка кучи в структуре, в которой такой порядок нарушен лишь в одном узле, вводится операция Heapify, принимающая в качестве аргумента номер вершины, в которой нарушен порядок.
	

        private void Heapify(int index = 1)
        {
            int l = index << 1;
            int r = l + 1;

            if (index > elnum || l > elnum)
            {
                return;
            }
            else
            {
                if (r > elnum)
                {
                    if (less(ar[l - 1], ar[index - 1]))
                        Utility.SwapArr(ref ar, l - 1, index - 1);
                }
                else
                {
                    if (lesseq(ar[index - 1], ar[r - 1]) && lesseq(ar[index - 1], ar[l - 1]))
                        return;
                    if (less(ar[r - 1], ar[l - 1]))
                    {
                        Utility.SwapArr(ref ar, r - 1, index - 1);
                        Heapify(r);
                    }
                    else
                    {
                        Utility.SwapArr(ref ar, l - 1, index - 1);
                        Heapify(l);
                    }
                }
            }
        }

Работает процедура на рекурсии и разборе случаев. В данном случае несложно заменить рекурсию на цикл, но я не стал этого делать для большей наглядности.
На основе процедуры Heapify работает извлечение минимума из нашей структуры:

	private double ExtractMin()
	{
		double m = ar[0];
		ar[0] = ar[--elnum];
		ar.RemoveAt(elnum);
		Heapify();
		return m;
	}

Перенос последнего элемента на вершину кучи нарушает в корневой вершине порядок кучи, поэтому в ней вызывается Heapify();
Абсолютно аналогичным образом, только проталкиванием "с дна", а не с вершины, добавляются в структуру новые элементы. Поскольку данная структура по сути является сбалансированным бинарным деревом, а время выполнения Heapify и AddElem линейно зависит от высоты кучи, то все три процедуры работают за логарифмическое время, а это как раз то, чего мы добивались.

##Тестирующий модуль
Основная часть моей программы отвечает за разбор и изменение синтаксического дерева методов с использованием библиотеки Roslyn, за компиляцию этого кода с нужными параметрами и за запуск и тестирование скомпилированного кода. Два основных класса, инкапсулирующие механику тестирования -  `public abstract class MethodForTesting` и `public abstract class MethodForTestingTaylor : MethodForTesting` отвечают за тестирование с использованием сопоставления с образцовой функцией, которую можно найти в атрибуте `FunctionName` и за сопоставление с идеальной суммой соответственно. Основным методом, генерирующим нужный для тестирования код и извлекающим всю нужную информацию из файлов, является метод 

            public static List<MethodForTesting> getMethodsFromFiles(
            string[] FileNames,
            string[] MethodNames,
            bool exclude = false,
            bool methodTypeDetection = false,
            Dictionary<string, MethodType> MethodTypes = null )
		
Он пробегает все файлы из массива `FileNames`, ищет в них методы `MethodNames`, а так же соответствующие им атрибуты `FunctionName`, в которых находятся образцовые выражения для сопоставления и оборачивает их в синтаксис методов, а так же разыскивает в файле интервальные функции с соответствующими названиями, вызывает их, используя метод 
`getIntervals(rt)`, который в свою очередь вызывает метод `IntervalMethod.Evaluate`, вызывающий соответствующий интервальный метод, и преобразующий полученную строку в массив специальных структур `Interval`.

Все три компонента - функция, образцовое библиотечное выражение и интервал (или два интервала, если функция зависит от двух аргументов) сопоставляются друг с другом, и в итоге, если нет противоречий, генерируется структура, включающая в себя всю необходимую для тестирования информацию о функции. Код на этом этапе не компилируется, ибо это повлечёт за собой переполнение памяти. Чтобы протестировать функцию, необходимо предварительно вызвать метод `CompileScript()`, и в зависимости от успешности или неуспешности компиляции вызывать метод `GetTestingReport()`, принимающий число итераций, число точек для тестирования и параметры (0-2). Этот метод является абстрактным, ибо его реализация зависит от количества аргументов функции. Наследники класса `MethodForTesting` для одного и двух аргументов реализуют его. Более того, поскольку тестирование функции зависит в большей степени от количества аргументов, чем от непосредственно метода выбора образца для тестирования, основные тестирующие блоки вынесены в статические методы `TestingUtilities.GetReportOneArg()` и `TestingUtilities.GetReportTwoArg()`, принимающие делегатов типов `Func<>` и `Action<>`, которые как раз и должны реализовывать отличающуюся функциональность.

Вернёмся к параметрам функции `getMethodsFromFiles()`. Если мы хотим, чтобы методы, указанные в `MethodsNames`, не включались в рассмотрение, а наоборот исключались, необходимо установить флаг exclude. Если мы хотим, чтобы по сигнатуре метода определялся его тип, устанавливаем флаг `methodTypeDetection`. Если в словаре `methodTypes` присутствует запись о методе, то его тип берётся из этого словаря. Иначе, если установлен флаг, мы пытаемся определить тип метода по сигнатуре. Если тип определить не удалось, пропускаем этот метод. Если же флаг не установлен и метода нет в словаре, то считаем, что его тип `MethodType.X`.

Что касается типов методов, все они определены в перечислении `MethodType`. Тип метода отвечает за количество аргументов функции (1-2) и её параметров (0-2). Из названий ясно, что означает тот или иной тип. В зависимости от типа метода выбирается реальный класс, к которому он относится - `*OneArg` или `*TwoArg`, а также тип структуры аргументов, которые передаются этому методу и образцовому методу при тестировании. Типы аргументов определены в пространствах имён `ArgsTypes` (для тестируемых методов, с последним аргументом - количеством итераций) и `ArgsTypesIdeal` (для образцовых методов, без количества итераций). Структуры именно такого типа нужны для того, чтобы сохранить возможность компиляции и в десятки раз ускорить выполнение программы.

Наконец, класс `MethodForTestingTaylor`, также абстрактный, позволяет проводить сопоставление с идеальными суммами. Он имеет двух потомков, конструкторы которых позволяют получить из экземпляра класса `MethodForTesting*` структуру, позволяющую сохранять слагаемые в структуре Heap, причём с тем же количеством аргументов. Следующий статический метод упрощает задачу получения метода для такого тестирования:

        public static MethodForTestingTaylor GetTaylorExtension(MethodForTesting m)
        {
            if (MethodForTesting.isOneArg(m.Type)) return new MethodForTestingTaylorOneArg((MethodForTestingOneArg)m);
            if (MethodForTesting.isTwoArg(m.Type)) return new MethodForTestingTaylorTwoArg((MethodForTestingTwoArg)m);
            throw new Exception();
        }

Как было упомянуто, перед компиляцией в теле метода ищется документирующий комментарий специального вида и заменяется на одну строчку кода. Без этого комментария к структуре Heap ничего не добавится, и сумма выйдет равной нулю.

Здесь достаточно сжато изложены основные моменты кода. За деталями обращайтесь к исходниками, прикреплённым к данному отчёту, диаграмме классов или по электронному адресу leopardile@yandex.ru.

##Скрипт на PowerShell, собирающий имена всех нужных файлов.

Для того, чтобы собрать все нужные методы со всего репозитория, был написан такой маленький скрипт на PowerShell

        cd C:\git_reps\summer_practice\opaque-func-lib
        Get-ChildItem -Path . -Filter *.cs -Recurse -Exclude "*Test*","*Info.cs","*Temporary*","*FunctionAttributes.cs",   "*Program.cs", "*Muradyan*" -File| % { Write $_.FullName} | Out-File "C:\git_reps\summer_practice\opaque-func-lib\Muradyan\CSlist.txt"

Он рекурсивно обходит все папки локального репозитория, опуская ненужные файлы - временные, описания атрибутов, тестов, а также файлы из моей папки.

# Результаты численных экспериментов
Тут приведены некоторые графики погрешностей, полученные в результате работы моей программы (да она ещё умеет сохранять отчёт в .csv и печатать на консоль, а метод PlotGraph.makeErrorPlots(), любезно предоставленный [qrodochenko](https://github.com/qrodochenko/) , позволяет по этим файлам создать графики абсолютных и относительных погрешностей.

###Функция Math_6_2_ln(), Kirillova, 1000 = N

[[ https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/TestingSystem/Reports/abs_err_plots/Math_6_2.png ]]

###Функция Math_4_2_ln(), Kirillova, 1000 = N

[[ https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/TestingSystem/Reports/abs_err_plots/Math_4_2_ln.png ]]

###Функция Sin_1(), Muradyan, 1000 = N

[[ https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/TestingSystem/Reports/abs_err_plots/Sin_1.png ]]

###Функция Math_17_2_ln(), Lebedev, 1000 = N

[[ https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/TestingSystem/Reports/abs_err_plots/Math_17_2.png ]]

# Список литературы
1. Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн. Алгоритмы: построение и анализ, 3-е издание = Introduction to Algorithms, Third Edition. — М.: «Вильямс», 2013. — 1328 с. — ISBN 978-5-8459-1794-2.
1. https://github.com/dotnet/roslyn/wiki/Scripting-API-Samples
3. https://joshvarty.wordpress.com/2014/07/06/learn-roslyn-now-part-2-analyzing-syntax-trees-with-linq/
5. https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Portable/Syntax/MethodDeclarationSyntax.cs
5. https://msdn.microsoft.com/ru-ru/library/system.io.path.getfilename(v=vs.110).aspx
6. https://msdn.microsoft.com/ru-ru/library/fk49wtc1(v=vs.110).aspx
7. https://msdn.microsoft.com/ru-ru/library/0yd65esw.aspx
8. https://msdn.microsoft.com/ru-ru/library/system.string.format(v=vs.110).aspx
8. https://msdn.microsoft.com/ru-ru/library/zkacc7k1.aspx
8. https://msdn.microsoft.com/ru-ru/library/sx2bwtw7.aspx
8. https://msdn.microsoft.com/ru-ru/library/system.tuple(v=vs.110).aspx
8. http://stackoverflow.com/questions/674479/how-do-i-get-the-directory-from-a-files-full-path
8. http://stackoverflow.com/questions/1399008/how-to-convert-a-relative-path-to-an-absolute-path-in-a-windows-application
8. http://www.tutorialspoint.com/csharp/csharp_data_types.htm
8. https://technet.microsoft.com/en-us/library/ee692796.aspx
8. http://www.cyberguru.ru/microsoft-net/csharp-net/csharp-learning-lambda-expressions.html
8. http://www.dotnetperls.com/constructor


# Приложения
Папка на GitHub: https://github.com/qrodochenko/opaque-func-lib/tree/master/Muradyan

Основной код тут: https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/TestingSystem/Program.cs

Скрипт PS: https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/getAllFuncs.ps1

Диаграмма классов, окончательное состояние: https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/ClassDiagram3.png

Тут код для построения графиков: https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/TestingSystem/PlotGraph.cs

В этих папках лежат отчёты и графики по тем функциям, по которым я смог их построить:
https://github.com/qrodochenko/opaque-func-lib/tree/master/Muradyan/TestingSystem/TestingSystem/Reports
https://github.com/qrodochenko/opaque-func-lib/tree/master/Muradyan/TestingSystem/TestingSystem/ReportsTaylor

Проект Visual Studio 2015: https://github.com/qrodochenko/opaque-func-lib/blob/master/Muradyan/TestingSystem/TestingSystem/TestingSystem.csproj

E-mail: leopardile@yandex.ru

