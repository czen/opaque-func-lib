1. Введение
2. Постановка задачи
3. Описание алгоритма
4. Результаты численных экспериментов
5. Список литературы
6. Приложения
6.1. Погрешности
6.2. Файлы.csv
6.3. Текст

Введение

В рамках летней практики на кафедре алгебры и дискретной математики наша группа занималась разработкой библиотеки математических функций с использованием аппроксимаций (ряды Тейлора, аппроксимации Паде, цепные дроби) и без них. Мне было поручено написание тестирующей системы для этой библиотеки. Как оказалось, эта задача не так уж проста - за эти две недели мне пришлось в некоторой мереосвоить язык программирования C# и библиотеку Roslyn, которая позволила мне получать синтаксические деревья методов, изменять их и тестировать на лету. Таким образом, практика безусловно пошла мне на пользу и, возможно, несколько повысила мой навык программирования.
Помимо прочего, я освоился с CVS Git и узнал, когда достигается минимальная погрешность при суммировании на ЭВМ. Класс Heap, реализацию которого на псевдокоде можно найти в [1], призван выполнять такое суммирование за O(NlogN).

Постановка задачи

В самом общем виде задачу можно сформулировать так: научиться тестировать математические функции из библиотеки OpaqueFunctions. Всё остальное по больше части зависело от меня и от отведённого на разработку времени. В итоге я реализовал следующие возможности:
1. Описал структуру данных Heap (пирамида), которая нужна для аккумуляции значений и выполнения их более или менее эффективного суммирования. Эта структура передаётся по ссылке в изменённую функцию из библиотеки OpaqueFunctions, в которой в специальном месте присутствует комментарий типа

/// add k

где k - текущий член, добавляемый к сумме. Этот комментарий изменяется моей программой на 

tst.AddElem(k);

что добавляет текущий элемент в пирамиду. После этого изменённая пирамида выполняет суммирование в нужном порядке за O(NlogN).

2. Описал классы, которые создают синтаксическое дерево файла, находят в нём атрибуты FunctionName и вытаскивают из этих атрибутов выражения, которые в идеале должны быть корректными с точки зрения C# математическими выражениями (впрочем, я несколько ослабил это требование: выражения эти нечувствительно к регистру). Они компилируется и используется как образцовые функции для сопоставления с написанной студентами аппроксимацией. По каким-то причинам никто не захотел следовать этим вроде бы простым требованиям, и я был вынужден сам написать функции для тестирования своего алгоритма.

Описание алгоритма

1. Пирамида, или куча (heap) - это структура данных, позволяющая извлекать минимальный элемент и вставлять элемент за время O(logN), где N - текуще число эементов в структуре. Логически она представляет из себя бинарное дерево, на котором введён порядок кучи, то есть родитель всегда меньше каждого из своих детей, а уровни дерева заполняются всегда сверху вниз, слева направо: у любой кучи только нижний слой может быть незаполненным, причём присутствуют только первые несколько элементов этого слоя. Из-за такой структуры пирамида легко упаковывается в массив - нумерация идёт с 1 слева направо и сверху вниз. Тогда к детям элемента i можно обращаться как 2*i и (2*i+1), а к родителю - [i/2], причём эти операции легко реализуются быстрыми битовыми сдвигами.
Для сохранения порядка кучи в структуре, в которой такой порядок нарушен лишь в одном узле, вводится операция Heapify, принимающая в качестве аргумента номер вершины, в которой нарушен порядок.
		private void Heapify(int index = 1)
        {
            int l = index << 1;
            int r = l + 1;

            if (index > elnum || l > elnum)
            {
                return;
            }
            else
            {
                if (r > elnum)
                {
                    if (less(ar[l - 1], ar[index - 1]))
                        Utility.SwapArr(ref ar, l - 1, index - 1);
                }
                else
                {
                    if (lesseq(ar[index - 1], ar[r - 1]) && lesseq(ar[index - 1], ar[l - 1]))
                        return;
                    if (less(ar[r - 1], ar[l - 1]))
                    {
                        Utility.SwapArr(ref ar, r - 1, index - 1);
                        Heapify(r);
                    }
                    else
                    {
                        Utility.SwapArr(ref ar, l - 1, index - 1);
                        Heapify(l);
                    }
                }
            }
        }
Работает процедура на рекурсии и разборе случаев. В данном случае несложно заменить рекурсию на цикл, но я не стал этого делать для большей наглядности.
На основе процедуры Heapify работает извлечение минимума из нашей структуры:
		private double ExtractMin()
		{
			double m = ar[0];
			ar[0] = ar[--elnum];
			ar.RemoveAt(elnum);
			Heapify();
			return m;
		}
Перенос последнего элемента на вершину кучи нарушает в корневой вершине порядок кучи, поэтому в ней вызывается Heapify();
Абсолютно аналогичным образом, только проталкиванием "с дна", а не с вершины, добавляются в структуру новые элементы. Поскольку данная структура по сути является сбалансированным бинарным деревом, а время выполнения Heapify и AddElem линейно зависит от высоты кучи, то все три процедуры работают за логарифмическое время, а это как раз то, чего мы добивались.

2.
		
		
Результаты численных экспериментов


Список литературы
[1] Кормен

Погрешности

